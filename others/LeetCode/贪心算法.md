### 0 预备知识：贪心算法，钞票支付问题
有1元、5元、10元、20元、100元、200元的钞票无穷多张。现在使用这些钞票支付x元，最少需要多少张？
> 贪心算法：遵循某种规律，不断贪心的选取当前最优策略的算法设计方法。

为什么上题会对？
5 = 1 + 1 + 1 + 1 + 1
10 = 5 + 5
20 = 10 + 10
100 = 20 + 20 + 20 + 20 + 20
200 = 100 + 100
所以当使用一张较大面额钞票时，若使用较小面额钞票替换，一定需要更多的其他面额的钞票！
故，当前最优解即为全局最优解，贪心成立。
如果增加7元面额，贪心算法不成立，不满足上面的替换规则

~~~
 #include < stdio.h >

int main()
{
    const int RMB[] = {200, 100, 20, 10, 5, 1};
    const int NUM = 6;      // 6种面值的钞票
    int X = 628;
    int count = 0;
    for (int i = 0; i < NUM; i++)
    {
        int use = X / REB[i];   // 需要面额为 RMB[i] 的 use张
        count += use;           // 总计增加use张
        X = X - RMB[i] * use;   // 将总额减去使用 RMB[i] 已组成的金额
        printf("需要面额为 %d 的 %d 张， "， RMB[i], use);
        printf("剩余需要支付金额 %d.\n", X);
    }
    printf("总共需要 %d 张\n", count);
    return 0;
}
~~~
### 1:分糖果 455 E
已知一些孩子和一些糖果，每个孩子有需求因子g，每个糖果有大小s，当某个糖果的大小s >= 某个孩子的需求因子g时，代表该糖果可以满足该孩子；求使用这些糖果，最多能满足多少个孩子？（某个孩子最多只能用1个糖果满足）
> g = [5,10,2,9,15,9], s = [6,1,20,3,8];最多满足3个孩子

> 找到需求因子 g = [2,5,9,9,10,15]； 糖果大小 s = [1,3,6,8,20]
1.某糖果不能满足某个需求因子，一定不能满足更大的需求因子
2.某需求因子可以由更小的糖果满足，则不需要用更大的糖果
3.需求因子更小更容易被满足，故优先从需求因子小的尝试

